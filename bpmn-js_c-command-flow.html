<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Command 기능(라벨 변경에 따른 flow 분기 자동지정)</title>
  <link rel="stylesheet" href="./vendor/bpmn-js/assets/diagram-js.css" />
  <link rel="stylesheet" href="./vendor/bpmn-js/assets/bpmn-font/css/bpmn-embedded.css" />
  <link rel="stylesheet" href="./vendor/bpmn-js/assets/bpmn-font/css/properties-panel.css" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
    }

    #controls {
      padding: 10px;
      background: #f0f0f0;
    }

    #main {
      flex: 1;
      display: flex;
      height: 100%;
    }

    #canvas {
      flex: 1;
      height: 100%;
    }

    #properties {
      width: 300px;
      border-left: 1px solid #ccc;
    }

    .bjs-properties-panel {
      font-family: sans-serif;
      font-size: 13px;
    }
      .djs-element.blue-task .djs-visual > :nth-child(1) {
    fill: blue !important;
  }

  .djs-element.red-task .djs-visual > :nth-child(1) {
    fill: red !important;
  }

  .djs-element.green-task .djs-visual > :nth-child(1) {
    fill: green !important;
  }
  </style>
</head>
<body>

  <div style="margin-left: 20px; font-size: 11px;">
    <br />
<h2>테스트 시나리오</h2>
<p>
  Task 라벨 변경에 따라 다음 flow가 결정됩니다.<br>
  <ul>
    <li><b>Take1</b>: 다음 flow는 Task 객체가 생성</li>
    <li><b>Take2</b>: 다음 flow는 Gateway 객체가 생성</li>
    <li><b>그 외</b>: 다음 flow는 EndEvent 객체가 생성</li>
  </ul>
</p>
1. Task 객체에 Take1을 입력하여 다음 flow는 Task 객체가 생성 확인<br />
2. Task 객체에 Take2을 입력하여 다음 flow는 Gateway 객체가 생성 확인<br />
3. Task 객체에 Take1, Take2 이외의 값을 입력하여 다음 flow는 EndEvent 객체가 생성 확인<br />
4. 우측 속성 창에서도 1~3번 동일하게 진행<br />
  </div>
  <div id="main">
    <div id="canvas"></div>
    <div id="properties"></div>
  </div>

  <!-- BPMN JS -->
  <!-- <script src="./vendor/bpmn-js/assets/bpmn-modeler-v11.5.0.js"></script> -->
  <script src="./vendor/bpmn-js/assets/bpmn-modeler-v18.6.2.js"></script>

  <!-- Properties Panel -->
  <script src="./vendor/bpmn-js/assets/bpmn-js-properties-panel-v5.30.0.js"></script>


  <script>
    (async function () {

    const camundaModdle = await fetch('./json/camundaModdle.json').then(response => response.json());
    const customModdle = await fetch('./json/customModdle.json').then(response => response.json());
    const bpmnXML = `<?xml version="1.0" encoding="UTF-8"?>
<bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL"
                  xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
                  xmlns:dc="http://www.omg.org/spec/DD/20100524/DC"
                  xmlns:camunda="http://camunda.org/schema/1.0/bpmn"
                  id="Definitions_1"
                  targetNamespace="http://bpmn.io/schema/bpmn">
  <bpmn:process id="Process_1" isExecutable="true">
    <bpmn:task id="Task_1"/>
  </bpmn:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
      <bpmndi:BPMNShape id="Task_1_di" bpmnElement="Task_1">
        <dc:Bounds x="100" y="100" width="100" height="80"/>
      </bpmndi:BPMNShape>
      <bpmndi:BPMNShape id="Task_2_di" bpmnElement="Task_2">
        <dc:Bounds x="250" y="100" width="100" height="80"/>
      </bpmndi:BPMNShape>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn:definitions>`;

    const bpmnModeler = new BpmnModeler({
      container: '#canvas',
      propertiesPanel: {
        parent: '#properties',
      },
      additionalModules: [
        window.BpmnJSPropertiesPanel.BpmnPropertiesPanelModule,
        window.BpmnJSPropertiesPanel.BpmnPropertiesProviderModule,
        window.BpmnJSPropertiesPanel.CamundaPlatformPropertiesProviderModule,
        window.BpmnJSPropertiesPanel.CamundaPlatformTooltipProvider,
        // {
        //   __init__: ['customPropertiesProvider'],
        //   customPropertiesProvider: ['type', CustomPropertiesProvider]
        // }
      ],
      moddleExtensions: {
        camunda: camundaModdle,
        custom: customModdle
      }
    });

    bpmnModeler.importXML(bpmnXML).then(() => {
      const canvas = bpmnModeler.get('canvas');
      const eventBus = bpmnModeler.get('eventBus');
      const elementFactory = bpmnModeler.get('elementFactory');
      const modeling = bpmnModeler.get('modeling');
      const selection = bpmnModeler.get('selection');

      requestAnimationFrame(() => {
        // 현재 뷰박스 얻기
        const viewbox = canvas.viewbox();

        // 원하는 위치로 이동
        canvas.viewbox({
          x: -40,
          y: 0,
          width: viewbox.width,
          height: viewbox.height
        });
      });

      let selectedElement;
      // click 시 selected element저장
      bpmnModeler.on('element.click', event => selectedElement = event.element);

      // 클래스 제거 및 추가를 통한 색상 적용
      const updateTaskColor = (element, changeLabel, target) => {
        // console.log(event.context.businessObject.$type)
        // const element = event.context.element;
        if (!element || element.businessObject.$type !== 'bpmn:Task') return;

        // 기존 마커 제거
        canvas.removeMarker(element, 'blue-task');
        canvas.removeMarker(element, 'red-task');
        canvas.removeMarker(element, 'green-task');
        // 나와 연결된 객체 삭제 (connection, object 둘다 삭제)
        const toRemove = [];
        // 연결된 시퀀스 플로우도 포함
        if (element.incoming) {
          toRemove.push(...element.incoming);
        }
        if (element.incoming.length && element.incoming[0]) {
          toRemove.push(element.incoming[0].target);
        }
        if (element.outgoing) {
          toRemove.push(...element.outgoing);
        }
        if (element.outgoing.length && element.outgoing[0]) {
          toRemove.push(element.outgoing[0].target);
        }
        modeling.removeElements(toRemove);

        let elementType;
        if (changeLabel === 'Take1') {
          canvas.addMarker(element, 'blue-task');
          elementType = 'bpmn:Task';
        } else if (changeLabel === 'Take2') {
          canvas.addMarker(element, 'red-task');
          elementType = 'bpmn:ExclusiveGateway';
        } else {
          canvas.addMarker(element, 'green-task');
          elementType = 'bpmn:EndEvent';
        }
        const position = {
          x: selectedElement.x + 220,
          y: selectedElement.y
        };
        console.log(target, elementType)
        // shape 생성 및 이름 속성 추가
        const shape = elementFactory.createShape({ type: elementType });

        modeling.createShape(shape, position, selectedElement.parent);
        modeling.connect(selectedElement, shape, {
          type: 'bpmn:SequenceFlow'
        });
        // selection.select(shape);
      };

      // label 변경 시 색상 적용 (contextPad, property 변경 시 둘다 적용)
      eventBus.on('commandStack.element.updateLabel.postExecute', event => updateTaskColor(event.context.element, event.context.newLabel, 1));

      // 이름 변경 시 색상 자동 갱신
      // eventBus.on('commandStack.element.updateProperties.postExecute', event => {
      //   updateTaskColor(event.context.element, event.context.properties.name, 2);
      // });

    }).catch(err => console.error('BPMN 로드 오류:', err));
    })();
  </script>
</body>
</html>
